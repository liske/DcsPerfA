#!/usr/bin/env perl

# DcsPerfA - DataCore Server Performance Analyzer
#
# Authors:
#   Thomas Liske <thomas@fiasko-nw.net>
#
# Copyright Holder:
#   2013 (C) Thomas Liske [http://fiasko-nw.net/~thomas/]
#
# License:
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this package; if not, write to the Free Software
#   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
#

use Chart::Gnuplot;
use Cwd qw(abs_path);
use File::Basename;
use File::Temp qw(tempfile);
use File::Slurp;
use Mojolicious::Lite;
use Mojo::IOLoop;
use JSON;

use constant {
    GNUPLOT_TIME_OFFSET => 946684800,
    IGNORE => 'IGNORE',
    BASEDIR => dirname(abs_path($0)),
};


my $manifest = decode_json( read_file(BASEDIR . '/public/raw/manifest.json') );
my %counters;
my %indexes;
my %groups;
for my $run (keys %$manifest) {
    $counters{$run} = decode_json( read_file(BASEDIR . '/public/raw/' . $run . '/counters.json') );
    foreach my $type (keys %{$counters{$run}}) {
	foreach my $pi (keys %{$counters{$run}->{$type}}) {
	    foreach my $group (keys %{$counters{$run}->{$type}->{$pi}}) {
		foreach my $counter (keys %{$counters{$run}->{$type}->{$pi}->{$group}->{Counters}}) {
		    $indexes{$run}->{$counters{$run}->{$type}->{$pi}->{$group}->{Counters}->{$counter}->{index}} = $counters{$run}->{$type}->{$pi}->{$group}->{Counters}->{$counter};
		    $groups{$run}->{$counters{$run}->{$type}->{$pi}->{$group}->{Counters}->{$counter}->{index}} = $counters{$run}->{$type}->{$pi}->{$group};
		}
	    }
	}
    }
}


get '/' => sub {
  my $self = shift;
  $self->render_static('index.html');
};

get '/css' => sub {
  my $self = shift;
  $self->render_static('/css');
};

get '/js' => sub {
  my $self = shift;
  $self->render_static('/js');
};

get '/raw' => sub {
  my $self = shift;
  $self->render_static('/raw');
};

get '/plot' => sub {
  my $self = shift;
  my $params = decode_json( $self->param('params') );
  my $run = $params->{run};

  return unless(exists($manifest->{$run}));

  my @dsets;
  foreach my $y (@{$params->{y}}) {
    push(@dsets, Chart::Gnuplot::DataSet->new(
	datafile => BASEDIR . "/public/raw/$run/data.csv",
	using => "$params->{x}:$y smooth csplines",
	title => $indexes{$run}->{$y}->{counter},
	style => 'lines lw 3',
    ));
  }

  my ($fh, $fn) = tempfile('plot-XXXXXXXX', TMPDIR => 1, SUFFIX => '.png');
  close($fh);

  my $group = $groups{$run}->{ $params->{y}->[0] };
  my $chart = Chart::Gnuplot->new(
    output => $fn,
    timefmt => '"%s"',
    xdata => 'time',
    legend => {
	position => 'below',
    },
    xrange => [$params->{from} - GNUPLOT_TIME_OFFSET, $params->{to} - GNUPLOT_TIME_OFFSET],
    yrange => [($group->{Min} < 0 ? $group->{Min}*1.1 : 0), $group->{Max}*1.1],
    grid => {
	width => 1,
    },
    tics => 'out',
  );
  $chart->command('set format y '.$group->{Format});
  $chart->plot2d(@dsets);

  my $data = read_file($fn);
  unlink($fn);

  $self->render(data => $data , format => 'png');
};

my @chars = ('a'..'z', 'A'..'Z', 0..9);
app->secret(join '', map { @chars[rand @chars] } 1 .. 24);
app->start;
